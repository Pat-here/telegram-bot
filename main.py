import telebot
import requests
import json
import time
from telebot import types
import logging
import os

# Konfiguracja logowania
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


WYKOP_API_KEY = os.getenv("WYKOP_API_KEY")
WYKOP_SECRET = os.getenv("WYKOP_SECRET")
BOT_TOKEN = os.getenv("TELEGRAM_TOKEN")

bot = telebot.TeleBot(BOT_TOKEN)

# Przechowywanie sesji u≈ºytkownik√≥w
user_sessions = {}

class WykopAPI:
    def __init__(self, api_key, secret):
        self.api_key = api_key
        self.secret = secret
        self.base_url = "https://wykop.pl/api/v3"
        self.token = None
        self.token_expires = 0
        
    def authenticate_app(self):
        """Autoryzuje aplikacjƒô w Wykop API v3"""
        try:
            url = f"{self.base_url}/auth"
            
            payload = {
                "data": {
                    "key": self.api_key,
                    "secret": self.secret
                }
            }
            
            headers = {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
            
            logger.info(f"Pr√≥ba autoryzacji z API Wykop...")
            response = requests.post(url, json=payload, headers=headers)
            
            if response.status_code == 200:
                auth_data = response.json()
                if 'data' in auth_data and 'token' in auth_data['data']:
                    self.token = auth_data['data']['token']
                    self.token_expires = time.time() + 3600  # Token wa≈ºny przez godzinƒô
                    logger.info("‚úÖ Autoryzacja z Wykop API udana")
                    return True
            
            logger.error(f"‚ùå B≈ÇƒÖd autoryzacji: {response.status_code} - {response.text}")
            return False
            
        except Exception as e:
            logger.error(f"‚ùå WyjƒÖtek podczas autoryzacji: {e}")
            return False
    
    def get_headers(self):
        """Zwraca nag≈Ç√≥wki z tokenem autoryzacji"""
        if not self.token or time.time() >= self.token_expires:
            if not self.authenticate_app():
                return None
        
        return {
            'Authorization': f'Bearer {self.token}',
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        }
    
    def get_entries(self, page=1, sort='hot'):
        """Pobiera wpisy z mikrobloga (entries)"""
        try:
            headers = self.get_headers()
            if not headers:
                return None
                
            url = f"{self.base_url}/entries"
            params = {
                'page': page,
                'sort': sort  # 'hot', 'newest', 'active'
            }
            
            logger.info(f"Pobieranie wpis√≥w z mikrobloga...")
            response = requests.get(url, headers=headers, params=params)
            
            if response.status_code == 200:
                logger.info("‚úÖ Wpisy pobrane pomy≈õlnie")
                return response.json()
            elif response.status_code == 401:
                # Token wygas≈Ç, spr√≥buj ponownie
                logger.info("Token wygas≈Ç, ponawiam autoryzacjƒô...")
                self.token = None
                return self.get_entries(page, sort)
            else:
                logger.error(f"‚ùå B≈ÇƒÖd pobierania wpis√≥w: {response.status_code} - {response.text}")
                return None
                
        except Exception as e:
            logger.error(f"‚ùå WyjƒÖtek podczas pobierania wpis√≥w: {e}")
            return None

# Inicjalizacja Wykop API
wykop_api = WykopAPI(WYKOP_API_KEY, WYKOP_SECRET)

def create_main_menu():
    """Tworzy g≈Ç√≥wne menu bota"""
    keyboard = types.InlineKeyboardMarkup()
    keyboard.add(types.InlineKeyboardButton("üìà Wykop TOP Posts", callback_data="wykop_menu"))
    return keyboard

def create_wykop_menu():
    """Tworzy menu Wykop"""
    keyboard = types.InlineKeyboardMarkup()
    keyboard.add(types.InlineKeyboardButton("üîç PrzeglƒÖdaj posty", callback_data="browse_posts"))
    keyboard.add(types.InlineKeyboardButton("üîô Powr√≥t do menu g≈Ç√≥wnego", callback_data="main_menu"))
    return keyboard

def create_post_navigation(current_index, total_posts):
    """Tworzy nawigacjƒô dla post√≥w"""
    keyboard = types.InlineKeyboardMarkup()
    
    # Pierwszy rzƒÖd - nawigacja
    row1 = []
    if current_index > 0:
        row1.append(types.InlineKeyboardButton("‚¨ÖÔ∏è Poprzedni", callback_data=f"post_prev_{current_index}"))
    if current_index < total_posts - 1:
        row1.append(types.InlineKeyboardButton("‚û°Ô∏è Nastƒôpny", callback_data=f"post_next_{current_index}"))
    
    if row1:
        keyboard.row(*row1)
    
    # Drugi rzƒÖd - akcje
    keyboard.add(types.InlineKeyboardButton("üîß U≈ºyj Posta (w konstrukcji)", callback_data="use_post"))
    keyboard.add(types.InlineKeyboardButton("üîô Powr√≥t do menu Wykop", callback_data="wykop_menu"))
    
    return keyboard

def format_post(post_data):
    """Formatuje wpis do wy≈õwietlenia"""
    try:
        # Obs≈Çuga r√≥≈ºnych struktur danych z API
        author = "Nieznany"
        if 'author' in post_data:
            if isinstance(post_data['author'], dict):
                author = post_data['author'].get('username', post_data['author'].get('login', 'Nieznany'))
            else:
                author = str(post_data['author'])
        
        # Obs≈Çuga g≈Ços√≥w
        plus = 0
        minus = 0
        if 'votes' in post_data:
            votes = post_data['votes']
            if isinstance(votes, dict):
                plus = votes.get('up', votes.get('plus', 0))
                minus = votes.get('down', votes.get('minus', 0))
        
        comments_count = post_data.get('comments_count', 0)
        content = post_data.get('content', post_data.get('body', 'Brak tre≈õci'))
        
        # Obcinamy tre≈õƒá je≈õli jest zbyt d≈Çuga
        if len(content) > 800:
            content = content[:800] + "..."
        
        # Usuwamy tagi HTML je≈õli sƒÖ obecne
        import re
        content = re.sub(r'<[^>]+>', '', content)
        
        formatted_post = f"""
üë§ **Autor:** @{author}
üëç **Plus:** {plus} | üëé **Minus:** {minus}
üí¨ **Komentarze:** {comments_count}

üìù **Tre≈õƒá:**
{content}
        """
        
        return formatted_post.strip()
    except Exception as e:
        logger.error(f"B≈ÇƒÖd formatowania wpisu: {e}")
        return f"B≈ÇƒÖd formatowania wpisu: {e}"

@bot.message_handler(commands=['start'])
def start_command(message):
    """Obs≈Çuguje komendƒô /start"""
    user_id = message.from_user.id
    user_sessions[user_id] = {
        'posts': [],
        'current_post_index': 0
    }
    
    welcome_text = """
ü§ñ **Witaj w bocie Wykop Telegram!**

Ten bot pozwala przeglƒÖdaƒá popularne wpisy z mikrobloga Wykop.pl.

U≈ºyj menu poni≈ºej, aby nawigowaƒá po funkcjach bota.
    """
    
    bot.send_message(
        message.chat.id,
        welcome_text,
        parse_mode='Markdown',
        reply_markup=create_main_menu()
    )

@bot.callback_query_handler(func=lambda call: True)
def callback_handler(call):
    """Obs≈Çuguje wszystkie callback queries"""
    user_id = call.from_user.id
    
    try:
        if call.data == "main_menu":
            bot.edit_message_text(
                "üè† **Menu G≈Ç√≥wne**\n\nWybierz opcjƒô:",
                call.message.chat.id,
                call.message.message_id,
                parse_mode='Markdown',
                reply_markup=create_main_menu()
            )
            
        elif call.data == "wykop_menu":
            bot.edit_message_text(
                "üìà **Wykop TOP Posts**\n\nWybierz akcjƒô:",
                call.message.chat.id,
                call.message.message_id,
                parse_mode='Markdown',
                reply_markup=create_wykop_menu()
            )
            
        elif call.data == "browse_posts":
            # Pobierz wpisy z Wykop
            bot.edit_message_text(
                "üîÑ Pobieranie popularnych wpis√≥w z mikrobloga...",
                call.message.chat.id,
                call.message.message_id
            )
            
            # U≈ºyj metody entries (mikrobloga)
            entries_data = wykop_api.get_entries(sort='hot')
            
            if entries_data and 'data' in entries_data:
                posts = entries_data['data']
                
                if posts and len(posts) > 0:
                    # Zapisz wpisy w sesji u≈ºytkownika
                    if user_id not in user_sessions:
                        user_sessions[user_id] = {}
                    
                    user_sessions[user_id]['posts'] = posts
                    user_sessions[user_id]['current_post_index'] = 0
                    
                    # Wy≈õwietl pierwszy wpis
                    first_post = posts[0]
                    formatted_post = format_post(first_post)
                    
                    bot.edit_message_text(
                        f"üìä **Wpis 1/{len(posts)}**\n\n{formatted_post}",
                        call.message.chat.id,
                        call.message.message_id,
                        parse_mode='Markdown',
                        reply_markup=create_post_navigation(0, len(posts))
                    )
                else:
                    bot.edit_message_text(
                        "‚ùå Nie znaleziono wpis√≥w na mikroblogu.",
                        call.message.chat.id,
                        call.message.message_id,
                        reply_markup=create_wykop_menu()
                    )
            else:
                bot.edit_message_text(
                    "‚ùå B≈ÇƒÖd podczas pobierania wpis√≥w z Wykop API.\n\n"
                    "Mo≈ºliwe przyczyny:\n"
                    "‚Ä¢ Problem z autoryzacjƒÖ API\n"
                    "‚Ä¢ Tymczasowy problem z serwerem Wykop\n"
                    "‚Ä¢ Nieprawid≈Çowe klucze API",
                    call.message.chat.id,
                    call.message.message_id,
                    reply_markup=create_wykop_menu()
                )
                
        elif call.data.startswith("post_"):
            # Obs≈Çuga nawigacji po wpisach
            action_parts = call.data.split("_")
            action = action_parts[1]  # prev lub next
            current_index = int(action_parts[2])
            
            if user_id in user_sessions and 'posts' in user_sessions[user_id]:
                posts = user_sessions[user_id]['posts']
                
                if action == "prev" and current_index > 0:
                    new_index = current_index - 1
                elif action == "next" and current_index < len(posts) - 1:
                    new_index = current_index + 1
                else:
                    new_index = current_index
                
                user_sessions[user_id]['current_post_index'] = new_index
                
                # Wy≈õwietl wybrany wpis
                selected_post = posts[new_index]
                formatted_post = format_post(selected_post)
                
                bot.edit_message_text(
                    f"üìä **Wpis {new_index + 1}/{len(posts)}**\n\n{formatted_post}",
                    call.message.chat.id,
                    call.message.message_id,
                    parse_mode='Markdown',
                    reply_markup=create_post_navigation(new_index, len(posts))
                )
                
        elif call.data == "use_post":
            bot.answer_callback_query(
                call.id,
                "üîß Ta funkcja jest w trakcie konstrukcji!\n\nTutaj w przysz≈Ço≈õci bƒôdzie mo≈ºna wykorzystaƒá wybrany wpis.",
                show_alert=True
            )
            
        # Odpowiedz na callback query
        bot.answer_callback_query(call.id)
        
    except Exception as e:
        logger.error(f"B≈ÇƒÖd w callback_handler: {e}")
        bot.answer_callback_query(call.id, "‚ùå WystƒÖpi≈Ç b≈ÇƒÖd podczas przetwarzania")
        
        # Spr√≥buj wr√≥ciƒá do menu g≈Ç√≥wnego
        try:
            bot.edit_message_text(
                "‚ùå WystƒÖpi≈Ç b≈ÇƒÖd. Powr√≥t do menu g≈Ç√≥wnego.",
                call.message.chat.id,
                call.message.message_id,
                reply_markup=create_main_menu()
            )
        except:
            pass

@bot.message_handler(func=lambda message: True)
def handle_all_messages(message):
    """Obs≈Çuguje wszystkie pozosta≈Çe wiadomo≈õci"""
    bot.send_message(
        message.chat.id,
        "ü§ñ U≈ºyj /start aby uruchomiƒá bota i wy≈õwietliƒá menu.\n\n"
        "Bot pozwala przeglƒÖdaƒá popularne wpisy z mikrobloga Wykop.pl",
        reply_markup=create_main_menu()
    )

def test_wykop_connection():
    """Testuje po≈ÇƒÖczenie z Wykop API"""
    logger.info("üß™ Testowanie po≈ÇƒÖczenia z Wykop API...")
    
    if wykop_api.authenticate_app():
        logger.info("‚úÖ Autoryzacja z Wykop API udana")
        
        # Test pobierania wpis√≥w
        entries = wykop_api.get_entries()
        if entries and 'data' in entries:
            logger.info(f"‚úÖ Pobrano {len(entries['data'])} wpis√≥w z mikrobloga")
            return True
        else:
            logger.error("‚ùå B≈ÇƒÖd pobierania wpis√≥w")
            return False
    else:
        logger.error("‚ùå B≈ÇƒÖd autoryzacji z Wykop API")
        return False

if __name__ == "__main__":
    print("üöÄ Uruchamianie Bota Telegram-Wykop...")
    
    # Test po≈ÇƒÖczenia z Wykop API przed uruchomieniem bota
    if not test_wykop_connection():
        print("‚ùå Nie mo≈ºna nawiƒÖzaƒá po≈ÇƒÖczenia z Wykop API. Sprawd≈∫ klucze.")
        print("‚ö†Ô∏è  Bot bƒôdzie dzia≈Ça≈Ç, ale funkcje Wykop mogƒÖ nie dzia≈Çaƒá poprawnie.")
    
    print("‚úÖ Bot Telegram-Wykop uruchomiony!")
    print("üì± Naci≈õnij Ctrl+C aby zatrzymaƒá bota")
    print("üîë Pamiƒôtaj aby ustawiƒá prawid≈Çowy TOKEN w BOT_TOKEN!")
    
    try:
        bot.polling(none_stop=True)
    except KeyboardInterrupt:
        print("\n‚èπÔ∏è Bot zatrzymany przez u≈ºytkownika")
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd bota: {e}")
        logger.error(f"Krytyczny b≈ÇƒÖd bota: {e}")
